package com.graphle.graphlemanager.sweeper

import com.graphle.graphlemanager.Neo4JRepoAutoGenerated
import com.graphle.graphlemanager.file.AbsolutePathString
import com.graphle.graphlemanager.file.File
import com.graphle.graphlemanager.file.FileRepository
import com.graphle.graphlemanager.tag.Tag
import com.graphle.graphlemanager.tag.TagForFileFlattened
import com.graphle.graphlemanager.tag.TagRepository
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.data.neo4j.repository.Neo4jRepository
import java.util.UUID

class Neo4JSweeperTest {
    @BeforeEach
    fun init() {
        fileRepository.clear()
        tagRepository.clear()
    }

    fun givenInsertedMockValues() {
        fileRepository.addConnection("nonExistent", "1")
        fileRepository.addConnection("real", "2")

        fileRepository.addFile("nonExistent")
        fileRepository.addFile("fake")
        fileRepository.addFile("real")

        tagRepository.addTagToFile("nonExistent", "1", "val")
        tagRepository.addTagToFile("nonExistent", "2", "val")
        tagRepository.addTagToFile("fake", "0", "val")
        tagRepository.addTagToFile("real", "2", "val")
    }

    @Test
    fun `sweeps non-existent files keeps real files`() {
        givenInsertedMockValues()

        val sweeper = Neo4JSweeper(fileRepository, tagRepository)
        sweeper.sweep { it == "real" }

        // Files swept, and only the real one remains
        assertEquals(1, fileRepository.files.size)
        assertEquals(setOf("real"), fileRepository.files)

        // Only one connection remains which is connected to real
        assertEquals(1, fileRepository.fileConnections.size)
        assertEquals(listOf("real" to "2"), fileRepository.fileConnections)

        // Only Tag with real as a location is present
        assertEquals(1, tagRepository.tags.size)
        assertEquals(listOf(Tag("2", "val")), tagRepository.tags["real"])
    }

    interface FileRepositoryMock : FileRepository, Neo4jRepository<File, UUID> {
        val files: Set<String>
        val fileConnections: List<Pair<AbsolutePathString, String>>
        fun addFile(location: AbsolutePathString)
        fun addConnection(file: AbsolutePathString, relationship: String)
        fun clear()
    }

    val fileRepository: FileRepositoryMock =
        object : FileRepositoryMock, Neo4jRepository<File, UUID> by Neo4JRepoAutoGenerated() {
            private val _files = mutableSetOf<AbsolutePathString>()
            override val files: Set<String>
                get() = _files
            private val _fileConnections = mutableListOf<Pair<AbsolutePathString, String>>()
            override val fileConnections: List<Pair<AbsolutePathString, String>>
                get() = _fileConnections

            override fun addFile(location: AbsolutePathString) {
                _files += location
            }

            override fun addConnection(file: AbsolutePathString, relationship: String) {
                _fileConnections.add(file to relationship)
            }

            override fun clear() {
                _files.clear()
                _fileConnections.clear()
            }


            override fun removeFileByLocation(fileLocation: AbsolutePathString) {
                _files.remove(fileLocation)
                _fileConnections.removeIf { it.first == fileLocation }
            }

            override fun getFileLocationsByConnections(
                fromLocation: AbsolutePathString,
                relationshipName: String
            ) = TODO("Not necessary for tests")

            override fun findAll(): List<File> = files.toList().map { File(it, listOf(), listOf()) }
        }

    interface TagRepositoryMock : TagRepository, Neo4jRepository<Tag, UUID> {
        fun clear()
        val tags: Map<AbsolutePathString, List<Tag>>
    }

    val tagRepository: TagRepositoryMock =
        object : TagRepositoryMock, Neo4jRepository<Tag, UUID> by Neo4JRepoAutoGenerated() {
            private val _tags = mutableMapOf<AbsolutePathString, MutableList<Tag>>()
            override val tags: Map<AbsolutePathString, List<Tag>>
                get() = _tags

            override fun clear() {
                _tags.clear()
            }

            override fun tagsByFileLocation(fileLocation: AbsolutePathString): List<Tag> =
                _tags[fileLocation] ?: listOf()

            override fun addTagToFile(
                fileLocation: AbsolutePathString,
                tagName: String,
                tagValue: String
            ) {
                val newTag = Tag(tagName, tagValue)
                if (_tags.containsKey(fileLocation)) _tags[fileLocation]!!.add(newTag)
                else _tags[fileLocation] = mutableListOf(newTag)
            }

            override fun addTagToFile(
                fileLocation: AbsolutePathString,
                tagName: String
            ) {
                val newTag = Tag(tagName, null)
                if (_tags.containsKey(fileLocation)) _tags[fileLocation]!!.add(newTag)
                else _tags[fileLocation] = mutableListOf(newTag)
            }

            override fun filesByTag(tagName: String): List<TagForFileFlattened> {
                return _tags
                    .filter { pair ->
                        pair.value
                            .map { tag -> tag.name }
                            .contains(tagName)
                    }
                    .flatMap {
                        it.value.map { tag ->
                            TagForFileFlattened(
                                location = it.key,
                                tagName = tag.name,
                                tagValue = tag.value
                            )
                        }
                    }
            }

            override fun removeOrphanTags() {
                val tagKeys = _tags.map { it.key }
                tagKeys.forEach { if (!fileRepository.files.contains(it)) _tags.remove(it) }
            }
        }
}